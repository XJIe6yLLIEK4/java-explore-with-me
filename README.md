# ExploreWithMe — обзор, архитектура и инженерные практики

## 1) Назначение проекта
**ExploreWithMe** — платформа для публикации и поиска событий с отдельным сервисом статистики просмотров и обращений. Репозиторий организован как multi‑module/mono‑repo с двумя сервисами:
- **`ewm-main-service`** — домен событий (категории, подборки, заявки на участие, модерация, публичное/приватное/админ‑API).
- **`stats`** — сбор «хитов» и агрегация статистики для аналитики трафика и просмотров.

Есть спецификации API (OpenAPI/Swagger) для обоих сервисов и инфраструктура локального запуска (Docker/Compose).

---

## 2) Архитектурные стили и принципы
- **Microservices‑like decomposition** (два автономных сервиса в одном репо): *Main* и *Stats* развёртываются независимо и общаются по **REST**.
- **Layered Architecture (n‑tier)** внутри каждого сервиса: `Controller → Service → Repository/DAO → DB`.
- **DDD‑подход (bounded contexts)**: контексты *Events* и *Stats* разделены; модель домена не «протекает» между сервисами.
- **API‑first**: контракт задаётся **OpenAPI**, генерация клиентов/валидации по спецификациям.
- **Ports & Adapters (Hexagonal hints)**: внешние интеграции (клиент статистики, e‑mail/уведомления и т. п.) инкапсулированы за интерфейсами.
- **CQRS‑подход (selective)**: команды/запросы логически разведены, чтение статистики не влияет на запись домена.
- **Идемпотентность** для операций записи и повторной доставки (ретраи HTTP‑клиента).
- **Fail‑fast** и **обработка исключений** централизована (глобальный обработчик ошибок, единый формат error response).

---

## 3) Паттерны программирования
- **DTO + Mapper** для изоляции веб‑контрактов от домена (возможен **MapStruct**/ручные мапперы).
- **Repository** (JPA/JDBC) и, при необходимости, **Specification** для гибкой фильтрации и сортировки.
- **Factory/Builder** для сборки агрегатов домена.
- **Strategy** (например, разные политики сортировки/подбора событий).
- **Template Method** в слоях интеграций (общие шаблоны вызовов HTTP‑клиента).
- **Validation** через Bean Validation (аннотации на DTO/командах).
- **AOP** для кросс‑срезочных задач (логирование, метрики, аудит).

---

## 4) Технологический стек
- Язык/сборка: **Java**, **Maven** (multi‑module).
- Веб/REST: *(как правило)* **Spring Boot**, **Spring Web**, **Spring Validation**, документирование через **springdoc‑openapi**/**Swagger**.
- Данные: **PostgreSQL** (или другая реляционная БД по профилю), миграции — **Flyway**/**Liquibase**.
- Доступ к данным: **Spring Data JPA**/**JDBC** (в зависимости от модуля).
- Интеграции: HTTP‑клиент (**WebClient/RestTemplate**), контракт — OpenAPI.
- Инфраструктура: **Docker**, **Docker Compose**; профили `dev/prod`.
- Качество кода: **Checkstyle**, **Lombok**.
- Наблюдаемость: **Spring Boot Actuator**, **Micrometer** → Prometheus/Grafana (по желанию); **корреляция запросов** (traceId).

> Конкретный набор библиотек и версий уточняется в `pom.xml` соответствующих модулей.

---

## 5) Нефункциональные требования (ориентиры)
- **Безопасность**: валидация входных данных, заголовки безопасности, ограничение размеров payload, базовая защита от OWASP Top‑10 на уровне API‑шлюза/сервиса.
- **Производительность**: пагинация/лимит результатов, индексы БД, кэширование горячих выборок (Caffeine/Redis).
- **Надёжность**: ретраи c **экспоненциальной задержкой**, таймауты/ограничения соединений, **circuit breaker** (Resilience4j — опционально).
- **Аудит**: журналирование бизнес‑событий (кто/что/когда).

---

## 6) Сборка и запуск
```bash
# сборка всего репозитория
mvn clean package

# локальный запуск всей системы
docker compose up -d
```
Порты/переменные окружения см. в `docker-compose.yml`. Открывайте Swagger‑UI по адресам из compose/конфигурации.

---

## 7) Тестирование
- **Unit**: JUnit 5, Mockito/AssertJ.
- **Integration**: запуск контекста, тесты репозиториев/контроллеров; **Testcontainers** для PostgreSQL — по желанию.
- **API‑контракты**: валидация соответствия OpenAPI (позитивные/негативные кейсы).

---

## 8) Принятые решения
- Разделение *Main* и *Stats* упрощает масштабирование и снижает связность.
- Контракт‑ориентированная разработка (OpenAPI) + строгая валидация.
- Слоистая архитектура и DDD‑границы для устойчивости к изменениям.
